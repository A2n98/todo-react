# Детали реализации.

## App.tsx

В App вызываем todo, основной компонент со всей логикой. Todo обёрнут контекстами. В них находится состояние со всеми задачами - массив, внутри которого список объектов. Работа с состоянием вынесена в отдельный файл todo-context

## local-storage.tsx

Задачи сохраняются в ls, лоигка работы вынесена в этот файл.

## todo.tsx

Основной компонент приложения.

> Для добавления новой задачи добавлен state newTaskText, хранит в себе текст нового приложения. При нажатии на + добавляет новую задачу, а состояние сбрасывает до TASK_TEXT_DEFAULT.
> Функция nextTaskId отдаёт новый id задачи типа number. Если задач в списке нет, то выдаёт 1, иначе максимальный id списка + 1. Функция нужна для опознавания задач в списке и изменения существующих объектов.

## list-tasks.tsx

Компонент для отображения списка задач в определённом статусе. Если передаваемый список не пуст отображает название с количеством задач, а также сами задачи.

## task.tsx

Компонент для выбора типа задачи и хранения состояния. В состоянии хранится статус задачи и id для поиска информации по задаче.
В зависимости от статуса вызывается один из компонентов:

1. PlanTask (Запланировано)
2. EditTask (Редактируется)
3. DoneTask (Выполнено)

При нажатии соответствующих кнопок меняется статус задачи и от этого отображается нужный компонент.
В файле shared.tsx находится объект taskStates, который хранит в себе коды статусов.

Некоторые детали реализации:

1. Компоненты PlanState и DoneState мало отличаются, но в ходе раздумий решено было их сделать отдельными компонентами для поддержки общей структуры (один статус = один компонент).
2. В todo-context в функции taskReducer кейс change_check можно было бы заменить на change_task, но решено было оставить два отдельных кейса. Это связано с тем, что запланированные задачи отправляются в конец запланированных задач, а выполненные в начало выполненных. Поскольку эта логика нужна была только при изменении свойства isChecked, то добавлять её в change_task показалось излишне.
